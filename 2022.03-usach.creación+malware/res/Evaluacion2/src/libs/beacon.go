package utils

import (
	"encoding/json"
	"fmt"
	amqp "github.com/rabbitmq/amqp091-go"
	"net"
	"strconv"
	"time"
)

type Message struct {
	Addresses []string `json:"addresses"`
	Port      int      `json:"port"`
}

func createBeaconMessage() (string, error) {
	var err error
	Print("Creating message for beacon")
	config, err := GetConfig()
	message := Message{Port: config.Server.Port}
	addresses, err := net.InterfaceAddrs()
	if err != nil {
		return "", err
	}
	for _, a := range addresses {
		if ipnet, ok := a.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
			if ipnet.IP.To4() != nil {
				Print("Found address %s", ipnet.IP.String())
				message.Addresses = append(message.Addresses, ipnet.IP.String())
			}
		}
	}
	data, err := json.Marshal(message)
	if err != nil {
		Print("Error converting message to JSon")
		return "", err
	}
	return string(data), nil
}

func publishMessage(message string) error {
	Print("Registering server at beacon")
	beacon := fmt.Sprintf("%s://%s:%s@%s/%s", config.Beacon.Protocol, config.Beacon.UserName,
		config.Beacon.Password, config.Beacon.Address, config.Beacon.Queue)
	Print("Dialing to beacon at %s", beacon)
	conn, err := amqp.Dial(beacon)
	if err != nil {
		Print("Error connecting to beacon at %s\n%v", beacon, err)
		return err
	}
	defer conn.Close()

	Print("Openning a channel to beacon")
	ch, err := conn.Channel()
	if err != nil {
		Print("Error creating a new channel to the beacon\n%v", err)
		return err
	}
	defer ch.Close()

	Print("Declaring an exchange to beacon")
	err = ch.ExchangeDeclare(config.Beacon.Exchange, "direct", true, false, false, false, nil)
	if err != nil {
		Print("Error declaring exchange beacon\n%v", err)
		return err
	}

	Print("Publishing message")
	err = ch.Publish(config.Beacon.Exchange, config.Beacon.RoutingKey, false, false,
		amqp.Publishing{ContentType: "text/plain", Body: []byte(message), Expiration: strconv.Itoa(config.Beacon.Expiration * 1000)})
	if err != nil {
		Print("Error publishing message to beacon\n%v", err)
		return err
	}
	Print("Message sent")

	return nil
}

func consumeMessageWithConfig(beacon *BeaconStruct) (*Message, error) {
	return nil, nil
}

func RegisterServer() error {
	message, err := createBeaconMessage()
	Print("Message for beacon:\n %s", message)
	if err != nil {
		Print("Error creating beacon message: %v", err)
		return err
	}
	for {
		publishMessage(message)
		time.Sleep(time.Duration(config.Beacon.Expiration) * time.Second)
	}
	return nil
}

func GetServer() error {
	return nil
}
